use clap::{App, Arg};
use failure::{Error, ResultExt};
use std::io::Write;
use std::path::Path;

mod build;

fn main() -> Result<(), Error> {
    let version = format!(
        "{}.{}.{}{}",
        env!("CARGO_PKG_VERSION_MAJOR"),
        env!("CARGO_PKG_VERSION_MINOR"),
        env!("CARGO_PKG_VERSION_PATCH"),
        option_env!("CARGO_PKG_VERSION_PRE").unwrap_or("")
    );
    let matches = App::new("ontio-wasm-build")
        .about("does awesome things")
        .version(version.as_str())
        .arg(
            Arg::with_name("input")
                .index(1)
                .required(true)
                .help("Wasm file generated by rustc compiler"),
        )
        .arg(Arg::with_name("output").index(2).required(true).help("Output wasm file name"))
        .arg(
            Arg::with_name("keepcustom")
                .long("keep-custom")
                .help("Keep custom section in output wasm file"),
        )
        .get_matches();

    let input = matches.value_of("input").expect("required arg can not be None");
    let output = matches.value_of("output").expect("required arg can not be None");
    let keep_custom = matches.is_present("keepcustom");

    let module =
        parity_wasm::deserialize_file(input).context("could not deserialize input wasm file")?;

    let module = build::build(module, !keep_custom)?;
    match Path::new(output).extension() {
        Some(ext) if ext == "wat" || ext == "wast" => {
            let buf = parity_wasm::serialize(module)?;
            let wat = wabt::wasm2wat(buf)?;
            let mut io = ::std::fs::File::create(output)?;
            io.write_all(wat.as_bytes())?;
        }
        _ => parity_wasm::serialize_to_file(output, module)?,
    }

    Ok(())
}

#[cfg(test)]
mod test;
